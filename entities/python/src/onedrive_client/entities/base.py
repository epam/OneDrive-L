"""Provides ``Entity`` class - a base class for project-wise DTOs."""
from abc import ABCMeta
import collections.abc
import enum
import importlib
from typing import Callable, Generic, Iterable, TypeVar

from google.protobuf.descriptor import (
    Descriptor,
    EnumDescriptor,
    FieldDescriptor
)
from google.protobuf.reflection import MakeClass

T = TypeVar('T')


_TYPE_MAP = {
    FieldDescriptor.TYPE_DOUBLE: (float,),
    FieldDescriptor.TYPE_FLOAT: (float,),
    FieldDescriptor.TYPE_INT64: (int,),
    FieldDescriptor.TYPE_UINT64: (int,),
    FieldDescriptor.TYPE_INT32: (int,),
    FieldDescriptor.TYPE_FIXED64: (int,),
    FieldDescriptor.TYPE_FIXED32: (int,),
    FieldDescriptor.TYPE_BOOL: (bool,),
    FieldDescriptor.TYPE_STRING: (str,),
    FieldDescriptor.TYPE_BYTES: (bytes,),
    FieldDescriptor.TYPE_UINT32: (int,),
    FieldDescriptor.TYPE_SFIXED32: (int,),
    FieldDescriptor.TYPE_SFIXED64: (int,),
    FieldDescriptor.TYPE_SINT32: (int,),
    FieldDescriptor.TYPE_SINT64: (int,),
}


class EntityCollection(collections.abc.MutableSequence, Generic[T]):
    """Typed collection that dynamically checks it's type.

    Has the same interface as built-in ``list``.

    Subclasses should override ``CHECK`` with a callable that takes a value
    and returns a boolean with of the type check result.

    Parameters
    ----------
    items : Iterable, optional
        Items with which the collection should initialized.

    Attributes
    ----------
    CHECK : Callable[T]
        Type-checking function, that must be overridden by subclasses.
    """

    CHECK: Callable[[T], bool] = None

    def __init__(self, items: Iterable = None):  # noqa: D102
        self.__list = []
        if items is not None:
            self.extend(items)

    def __getitem__(self, index):
        """Retrieve the element at 'index'."""
        return self.__list[index]

    def __setitem__(self, index, value):
        """Set a 'value' at 'index'."""
        value = self.__check(value)
        self.__list[index] = value

    def __delitem__(self, index):
        """Delete the element at 'index'."""
        del self.__list[index]

    def __len__(self):
        """Length of the collection."""
        return len(self.__list)

    def __eq__(self, other):
        """Compare to other collection."""
        return self.__list == other

    def __str__(self):
        """Represent as string."""
        return self.__repr__()

    def __repr__(self):
        """Represent as an executable expression."""
        return f'{self.__class__.__name__}({repr(self.__list)})'

    def insert(self, index, value):
        """Insert 'valiue' after 'index'."""
        value = self.__check(value)
        return self.__list.insert(index, value)

    @classmethod
    def __check(cls, item):
        """Perform type check and type cast."""
        try:
            item = cls.CHECK(item)  # pylint: disable=not-callable
        except TypeError:
            raise TypeError('Wrong collection item type.')
        return item


class _EntityMeta(ABCMeta):
    """A metaclass for ``Entity`` for various auxiliary purposes.

    Notes
    -----
    - Assigns ``_MESSAGE_CLASS`` class-attribute with a PB-message class
      generated by the original Protobuf Python plugin.
    """

    def __new__(mcs, name, bases, attributes, **kwargs):  # noqa: D102
        descriptor = attributes.get('_DESCRIPTOR')

        if descriptor is not None:
            attributes['_MESSAGE_CLASS'] = MakeClass(descriptor)

        type_ = super().__new__(mcs, name, bases, attributes, **kwargs)

        return type_


_REGISTRY = {}


class Entity(collections.abc.MutableMapping, metaclass=_EntityMeta):
    # pylint: disable=line-too-long
    """Simple dict-like class for DTOs with basic validation.

    Generally follows the interface of build-in ``dict``.

    With some additional features:
        - It enforces the schema.
             - It doesn't allow to assign keys that aren't allowed by
               the schema.
             - It checks the the types according to the schema.
             - It does the above for "oneof" and "repeated" fields too.
             - It automatically represents nested entities as instances of
               corresponding entity-classes.

    Notes
    -----
    - Currently this class pretty much mirrors Protobuf specs when it comes
      to type-checking behavior.
    - Implementation relies on matching structure of Python packages and
      Protobuf packages to retrieve corresponding classes.

    Examples
    --------
    Simple usage:
    >>> from onedrive_client.entities.common import LocalItem
    >>> local_item = LocalItem({'path': '/foo'})
    >>> assert local_item['path'] == '/foo'
    >>> local_item
    LocalItem({'path': '/foo'})

    ``Entity``-instances behave exactly like dict:
    >>> assert list(local_item.keys()) == ['path']
    >>> assert 'path' in local_item
    >>> local_item.update({'path': '/bar'})

    Complex fields are automatically converted to instances of
    the corresponding entity-classes:
    >>> local_item['metadata'] = {'size': 999, 'modified': 123456789,\
                                  'is_dir': True}
    >>> local_item
    LocalItem({'path': '/bar',
               'metadata': LocalItemMetadata({'size': 999,
                                              'modified': 123456789,
                                              'is_dir': True,
                                              'is_deleted': False})})

    Repeated fields. Notice repeated fields are set by default unlike
    complex fields. It's because it's Protobuf specs:
    >>> from onedrive_client.entities.onedrive import UploadStatus
    >>> upload_status = UploadStatus()
    >>> upload_status
    UploadStatus({'expiration_date_time': 0,
                  'next_expected_ranges': ExpectedRangeCollection([])})

    >>> upload_status['next_expected_ranges'].append({
    ...    'beginning': 0, 'end': 10
    ... })
    >>> upload_status
    UploadStatus({'expiration_date_time': 0,
                  'next_expected_ranges':
                  ExpectedRangeCollection([ExpectedRange({'beginning': 0,
                                                          'end': 10})])})

    Enum fields are represented by enum.IntEnum objects:
    >>> from onedrive_client.entities.onedrive import Drive
    >>> drive = Drive()
    >>> drive
    Drive({'drive_type': <DriveType.PERSONAL: 0>})
    >>> drive['drive_type'] = 1
    >>> drive
    Drive({'drive_type': <DriveType.BUSINESS: 1>})

    ``Entity`` classes provide dynamic type checking. They wont let
    user set value that violates the schema:
    >>> drive['drive_type'] = 100
    Traceback (most recent call last):
    ...
    TypeError
    >>> local_item['metadata']['foo'] = 123
    Traceback (most recent call last):
    ...
    TypeError

    """

    _DESCRIPTOR = None
    _MESSAGE_CLASS = None

    __FIELD_TYPE_ERROR_MESSAGE = 'Wrong value type.'

    def __init__(self, *args, **kwargs):  # noqa: D102
        self.__data = {}
        if args or kwargs:
            self.update(dict(*args, **kwargs))

    @staticmethod
    def __is_composite_field(descriptor: FieldDescriptor) -> bool:
        return descriptor.type == descriptor.TYPE_MESSAGE

    @staticmethod
    def __is_enum_field(descriptor: FieldDescriptor) -> bool:
        return descriptor.type == descriptor.TYPE_ENUM

    @staticmethod
    def __is_repeated_field(descriptor: FieldDescriptor) -> bool:
        return descriptor.label == descriptor.LABEL_REPEATED

    @classmethod
    def __get_field_descriptor(cls, name: str) -> FieldDescriptor:
        try:
            return cls._DESCRIPTOR.fields_by_name[name]
        except KeyError:
            raise TypeError('"%s" doesn\'t have the field "%s".' % (
                cls.__name__, name
            ))

    @staticmethod
    def __check_enum(enum_descriptor: EnumDescriptor, value: int) -> bool:
        return value in enum_descriptor.values_by_number

    @staticmethod
    def __import(spec):
        package, _, name = spec.rpartition('.')
        try:
            module = importlib.import_module(package)
        except ModuleNotFoundError:
            return None

        return getattr(module, name)

    @classmethod
    def __get_entity(cls, message_descriptor: Descriptor) -> type:
        return cls.__import(message_descriptor.full_name)

    __VIRTUAL_MODULE = __name__.rsplit('.', 1)[0] + '.virtual'

    @classmethod
    def __make_entity(cls, message_descriptor: Descriptor) -> type:
        """Make a "virtual" entity.

        Used for schemas that are defined within other schemas.
        """
        entity_cls = _REGISTRY.get(message_descriptor.full_name)
        if entity_cls is None:
            entity_cls = type(
                message_descriptor.name,
                (cls,),
                {'_DESCRIPTOR': message_descriptor,
                 '__module__': cls.__VIRTUAL_MODULE}
            )
            _REGISTRY[message_descriptor.full_name] = entity_cls

        return entity_cls

    @classmethod
    def __get_or_make_entity(cls, descriptor: Descriptor) -> type:
        """Retrieve entity-class or create it."""
        entity = cls.__get_entity(descriptor)
        if entity is None:
            entity = cls.__make_entity(descriptor)

        return entity

    @classmethod
    def __get_enum(cls, enum_descriptor: EnumDescriptor) -> type:
        return cls.__import(enum_descriptor.full_name)

    @classmethod
    def __make_enum(cls, enum_descriptor: EnumDescriptor) -> type:
        enum_cls = _REGISTRY.get(enum_descriptor.full_name)
        if enum_cls is None:
            enum_cls = enum.IntEnum(
                enum_descriptor.name,
                {d.name: d.number for d in enum_descriptor.values}
            )
            enum_cls.__module__ = cls.__VIRTUAL_MODULE
            _REGISTRY[enum_descriptor.full_name] = enum_cls

        return enum_cls

    @classmethod
    def __get_or_make_enum(cls, enum_descriptor: EnumDescriptor) -> type:
        """Retrieve enum-class or create it."""
        enum_cls = cls.__get_enum(enum_descriptor)
        if enum_cls is None:
            enum_cls = cls.__make_enum(enum_descriptor)
        return enum_cls

    def __make_collection(
        self,
        field_descriptor: FieldDescriptor
    ) -> type:
        """Create collection-class respecting the type of the field."""
        # pylint: disable=missing-docstring
        if self.__is_enum_field(field_descriptor):
            enum_cls = self.__get_or_make_enum(field_descriptor.enum_type)

            def check(e):
                if not isinstance(e, enum_cls):
                    try:
                        e = enum_cls(e)
                    except ValueError as exc:
                        raise TypeError(exc)
                return e

            name = field_descriptor.enum_type.name + 'Collection'
        elif self.__is_composite_field(field_descriptor):
            sub_entity = self.__get_or_make_entity(
                field_descriptor.message_type
            )

            def check(e):
                if not isinstance(e, sub_entity):
                    e = sub_entity(e)
                return e
            name = sub_entity.__name__ + 'Collection'
        else:
            type_ = self.__get_regular_field_types(field_descriptor)
            name = ''.join(t.__name__.capitalize() + 'Collection'
                           for t in type_)

            def check(e):
                if not isinstance(e, type_):
                    try:
                        e = type_(e)
                    except (ValueError, TypeError) as exc:
                        raise TypeError(exc)
                return e

        collection = type(
            name,
            (EntityCollection,),
            {'CHECK': check,
             '__module__': self.__VIRTUAL_MODULE}
        )
        return collection

    @staticmethod
    def __get_regular_field_types(descriptor):
        return _TYPE_MAP[descriptor.type]

    def __getitem__(self, item):
        """Retrieve an item respecting type-checking rules.

        - If a primitive or a enum field is not set - return a default value.
        - If a repeated value is not set - return an empty collection.
        - If a complex value is not set - raise ``KeyError``.
        - If a field is set - return it's value.
        """
        field_descriptor = self.__get_field_descriptor(item)

        if item in self.__data:
            return self.__data[item]
        if self.__is_enum_field(field_descriptor):
            enum_cls = self.__get_or_make_enum(field_descriptor.enum_type)
            value = self.__data[item] = enum_cls(
                field_descriptor.default_value
            )
            return value
        elif self.__is_repeated_field(field_descriptor):
            collection_cls = self.__make_collection(field_descriptor)
            value = self.__data[item] = collection_cls()
            return value
        elif not self.__is_composite_field(field_descriptor):
            value = field_descriptor.default_value
            self.__data[item] = value
            return value
        else:
            raise KeyError(item)

    def __setitem__(self, key, value):
        """Set item and apply type-checking rules.

        - Enforce type of the field. Raise ``TypeError``
          if the type doesn't match.
        - Don't allow multiple fields within oneof group to be set.
        """
        field_descriptor = self.__get_field_descriptor(key)

        oneof = field_descriptor.containing_oneof
        if oneof is not None:
            try:
                next(f.name for f in oneof.fields
                     if f.name != key and f.name in self)
            except StopIteration:
                pass
            else:
                raise TypeError(
                    'Can\'t set one of the OneOf fields '
                    'while other is present.'
                )
        if self.__is_repeated_field(field_descriptor):
            collection_cls = self.__make_collection(field_descriptor)
            items = collection_cls(value)
            self.__data[key] = items
            return
        elif self.__is_composite_field(field_descriptor):
            sub_entity_cls = self.__get_or_make_entity(
                field_descriptor.message_type
            )
            if not isinstance(value, sub_entity_cls):
                value = sub_entity_cls(value)
            self.__data[key] = value
            return
        elif self.__is_enum_field(field_descriptor):
            enum_cls = self.__get_or_make_enum(field_descriptor.enum_type)
            if not isinstance(value, enum_cls):
                try:
                    value = enum_cls(value)
                except ValueError as exc:
                    raise TypeError(exc)
            self.__data[key] = value
            return
        else:
            type_ = self.__get_regular_field_types(field_descriptor)
            if not isinstance(value, type_):
                raise TypeError(self.__FIELD_TYPE_ERROR_MESSAGE)
            self.__data[key] = value

    def __delitem__(self, key):
        """Delete item respecting field types.

        - Only composite fields could be unset.
        - Repeated fields are cleared.
        - Primitive and enum fields are set to a default value.
        """
        field_descriptor = self.__get_field_descriptor(key)

        try:
            if self.__is_composite_field(field_descriptor):
                del self[key]
                return
            elif self.__is_repeated_field(field_descriptor):
                self[key].clear()
                return

            del self.__data[key]
        except KeyError:
            raise KeyError(key)

    def __iter__(self):
        """Iterate over available fields."""
        for field, descriptor in self._DESCRIPTOR.fields_by_name.items():
            if (self.__is_repeated_field(descriptor) or
                self.__is_enum_field(descriptor) or
                (not self.__is_composite_field(descriptor) or
                 descriptor.name in self.__data)):
                yield field

    def __len__(self):
        """Count the keys."""
        return len(list(self.__iter__()))

    def __str__(self):
        """Represent as a string."""

    def __repr__(self):
        """Represent as an executable expression."""
        return '%s({%s})' % (
            self.__class__.__name__,
            ', '.join(map(lambda e: ': '.join(map(repr, e)), self.items()))
        )

    def to_protobuf(self):
        """Serialize to Protobuf wire format."""
        raise NotImplementedError

    def from_protobuf(self, input_bytes):
        """Deserialize to Protobuf wire format."""
        raise NotImplementedError
