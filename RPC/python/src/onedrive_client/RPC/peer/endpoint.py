"""Provides ``Endpoint`` class."""
import collections
import random as rnd
import time as timelib
from typing import Callable, Dict, List, NamedTuple, Optional, Sequence, Set
import uuid
import weakref

import gevent
import gevent.event
import gevent.lock
import gevent.queue
from google.protobuf.message import DecodeError, Message
import logbook

from onedrive_client.RPC.models import (
    Action,
    Event,
    Halted,
    Model,
    UnrecognizedEventsSet
)
from onedrive_client.RPC.RPC_pb2 import Packet
from onedrive_client.RPC.transport import UnknownIdentity
from .exceptions import (
    EndpointIsClosed,
    IncompatiblePacket,
    InvalidAction
)
from .remote_peer_state import RemotePeerState
from .window import (
    SenderWindow,
    UnknownID
)
from ..utils.logbook import Logger

LOGGER = Logger(__name__)


class Endpoint:
    """Session endpoint - represents state of the peer in a session.

    This class contains all the logic of the RPC level - it tracks state
    of the session and executes necessary actions according to the
    communication model.
    It works by a simple algorithm:

        - It generates events when a packet is sent or received
        - Feeds the events to the state machine defined by the communication
          model
        - The model produces a set of actions.
        - The endpoint executes them.

    Parameters 'service_id' and 'method_id' are used to determine to which
    method the packet belongs to.

    Parameters
    ----------
    service_id
        Service ID.
    method_id
        Method ID.
    model
        ``Model`` instance associated with the method.
    message_cls
        Protobuf message class which represents payload.
    acknowledgement_interval
        Time interval after which a packet that requires acknowledgement should
        be re-sent in case if it wasn't acknowledged by the remote peer.
    heartbeat_interval
        Time interval with which "heartbeat packets" will be sent in case if
        within this interval no packets of any kind were sent to the remote
        peer.
    alive_timeout
        Time interval within which if no packets were received from the peer
        it is considered to be "dead".
    send
        A callable that performs sending over the network. It must accept
        arbitrary bytes sequence, a list of peer identities and return a list
        of identities to which the data was sent successfully.
    sender_window_size
        Size of a sliding-window of packet IDs of the sending side.
    receiver_window_size
        Size of a sliding-window of packet IDs of the sending side.
    session_id
        Pre-defined ID of the session which would be used for all the packets
        generated by the endpoint and which would be expected to be a
        session ID of all inbound packets.
        If not provided - a random ID is generated.
    time
        Time function. A callable that returns current time in Epoch format
        as a floating point number.

    Notes
    -----
    Some of the methods like ``__heartbeater()`` or ``__sender()`` are
    implemented like static methods which accept the "self" endpoint instance
    as a weak reference to not prevent garbage collector from collecting the
    endpoint instance when they are running continuously as greenlets.
    """
    # pylint: disable=protected-access
    SENDER_WINDOW_SIZE = 1000
    RECEIVER_WINDOW_SIZE = 1000

    def __init__(
        self,
        service_id: int,
        method_id: int,
        model: Model,
        message_cls: Message,
        acknowledgement_interval: float,
        heartbeat_interval: float,
        alive_timeout: float,
        send: Callable[[bytes, Sequence[str]], Sequence[str]],
        sender_window_size: int = SENDER_WINDOW_SIZE,
        receiver_window_size: int = RECEIVER_WINDOW_SIZE,
        session_id: bytes = None,
        time: Callable[[], float] = timelib.time
    ):
        # Attributes that are initialized from the arguments.
        if model.SINGLETON_SESSION:
            self.__session_id = None
        elif session_id is None:
            self.__session_id = self.__session_id = uuid.uuid4().bytes
        else:
            self.__session_id = session_id

        self.__service_id               = service_id
        self.__method_id                = method_id
        self.__model                    = model
        self.__message_cls              = message_cls
        self.__acknowledgement_interval = acknowledgement_interval
        self.__heartbeat_interval       = heartbeat_interval
        self.__alive_timeout            = alive_timeout
        self.__send                     = send
        self.__sender_window_size       = sender_window_size
        self.__receiver_window_size     = receiver_window_size
        self.__time                     = time

        # Callbacks.
        self.__send_callbacks: Dict[str, Callable[[bool], None]] = {}
        self.__peer_lost_callbacks = []
        self.__receive_callbacks: List[Callable[str, Message], None] = []

        # Current state machine state.
        self.__current_state = self.__model.LOCAL_BEGIN

        # Single queue for all the events generated when packet is sent or
        # received.
        self.__event_queue: gevent.queue.PriorityQueue = (
            gevent.queue.PriorityQueue()
        )
        # Window that tracks sent packet IDs.
        self.__sender_window: SenderWindow = SenderWindow(sender_window_size)
        # Global lock that guards against race conditions when any local state
        # is changed.
        self.__lock: gevent.lock.RLock = gevent.lock.RLock()
        # State of remote peers.
        self.__remote_peers: Dict[str, RemotePeerState] = {}

        # Spawn the greenlets.
        self.__hearbeater_greenlet: gevent.Greenlet = gevent.spawn(
            self.__heartbeater,
            weakref.ref(self)
        )
        self.__alive_checker_greenlet: gevent.Greenlet = gevent.spawn(
            self.__alive_checker,
            weakref.ref(self)
        )
        self.__sender_greenlet: gevent.Greenlet = gevent.spawn(
            self.__sender,
            weakref.ref(self)
        )
        self.__pruner_greenlet: gevent.Greenlet = gevent.spawn(
            self.__pruner,
            weakref.ref(self)
        )
        self.__executor_greenlet: gevent.Greenlet = gevent.spawn(
            self.__executor,
            endpointref=weakref.ref(self)
        )

    @property
    def session_id(self) -> Optional[bytes]:
        """Session ID associated with the endpoint.

        ``None`` in case if the session is a singleton-session.
        """
        return self.__session_id

    @property
    def __not_stale_remote_peers(self) -> Dict[str, RemotePeerState]:
        """Remote peers that are not "stale".

        Stale peer is a peer that is not going to send or receive any packets
        anymore and hence could be "forgotten".
        """
        return {k: v for k, v in self.__remote_peers.items()
                if not v.is_stale}

    @property
    def __not_closed_remote_peers(self) -> Dict[str, RemotePeerState]:
        """Remote peers that which associated model state is halted."""
        return {k: v for k, v in self.__remote_peers.items()
                if not v.is_closed}

    @staticmethod
    def __pruner(endpointref: weakref.ReferenceType):
        """Continuously prunes """
        endpoint: Optional[Endpoint] = None
        while True:
            del endpoint
            endpoint: Endpoint = endpointref()
            if endpoint is None:
                break
            if endpoint.is_closed:
                break

            gevent.sleep(0.05)

            for identity, remote_peer in list(endpoint.__remote_peers.items()):
                if remote_peer.is_stale:
                    assert not remote_peer.unacknowledged_sent_packets
                    endpoint.__drop_remote_peer(identity)

    @staticmethod
    def __alive_checker(endpointref: weakref.ReferenceType):
        """Continuously checks for dead peers."""
        endpoint: Optional[Endpoint] = None
        while True:
            del endpoint
            endpoint: Endpoint = endpointref()
            if endpoint is None:
                break
            if endpoint.is_closed:
                break

            gevent.sleep(endpoint.__alive_timeout / 2.0)

            for identity, state in list(endpoint.__remote_peers.items()):
                with logbook.Processor(
                    lambda r, id_=identity: r.extra.update({'identity': id_})
                ):
                    if state.is_alive_timeout_exceeded:
                        LOGGER.warning(
                            'Alive timeout exceeded. Terminating...'
                        )
                        endpoint.__drop_remote_peer(identity)
                        for callback in endpoint.__peer_lost_callbacks:
                            # pylint: disable=broad-except
                            try:
                                callback(identity)
                            except Exception as exc:
                                LOGGER.exception(exc)

    @staticmethod
    def __heartbeater(endpointref: weakref.ReferenceType):
        endpoint: Optional[Endpoint] = None
        while True:
            del endpoint

            endpoint = endpointref()
            if endpoint is None:
                break
            if endpoint.is_closed:
                break

            gevent.sleep(endpoint.__heartbeat_interval / 2.0)
            try:
                identity, state = rnd.choice(list(
                    endpoint.__remote_peers.items()
                ))
            except IndexError:
                continue

            if not state.is_heartbeat_interval_exceeded:
                continue

            packet = endpoint.__create_base_packet()
            packet.is_heartbeat = True
            endpoint.__send_packet(
                base_packet=packet,
                identity=identity
            )

    def __create_base_packet(self):
        # pylint: disable=no-member
        packet = Packet()
        packet.service_id = self.__service_id
        packet.method_id = self.__method_id
        if self.__session_id is not None:
            packet.session_id.value = self.__session_id
        return packet

    @staticmethod
    def __sender(endpointref: weakref.ReferenceType):
        """Continuously processes send-queue."""
        endpoint: Optional[Endpoint] = None
        while True:
            del endpoint
            gevent.sleep(0.001)

            endpoint: Optional[Endpoint] = endpointref()
            if endpoint is None:
                break
            if endpoint.is_closed:
                break

            with endpoint.__lock:
                try:
                    identity, remote_peer = rnd.choice([
                        (i, s) for i, s in (
                            endpoint.__not_stale_remote_peers.items()
                        )
                        if (len(s.send_queue) > 0 or
                            len(s.packets_to_resend) > 0 or
                            len(s.unacknowledged_received_packets) > 0)
                    ])
                except IndexError:
                    continue

                packet = endpoint.__create_base_packet()
                send_callback = None

                new_id = False
                if len(remote_peer.send_queue) > 0:
                    LOGGER.trace('Sending message...')
                    base_packet, send_callback = (
                        remote_peer.send_queue.peek_nowait()
                    )
                    packet.CopyFrom(base_packet)
                    new_id = True
                elif len(remote_peer.packets_to_resend) > 0:
                    LOGGER.trace('Re-sending packet...')
                    base_packet = remote_peer.packets_to_resend[0]
                    packet.CopyFrom(base_packet)
                elif len(remote_peer.unacknowledged_received_packets) > 0:
                    LOGGER.trace('Acknowledging received packet...')
                    new_id = True
                else:
                    continue

                if new_id:
                    LOGGER.trace('Generating new packet ID...')
                    packet_id = next(
                        endpoint.__sender_window.free_ids(1),
                        None
                    )
                    if packet_id is None:
                        # Sender-window is full,
                        # Reschedule sending of the packet.
                        continue

                    packet.packet_id = packet_id
                    packet.window_start = endpoint.__sender_window.start

                if send_callback is not None:
                    endpoint.__send_callbacks[packet.packet_id] = send_callback

                if len(remote_peer.unacknowledged_received_packets) > 0:
                    packet.acknowledges.extend(
                        set(remote_peer.unacknowledged_received_packets) -
                        set(packet.acknowledges)
                    )
                    LOGGER.trace('Outbound packet acknowledges: {}',
                                 ', '.join(map(str, packet.acknowledges)))

                LOGGER.trace('Sending packet to {}...', identity)
                LOGGER.trace('Packet to be sent: \n{}', repr(packet))
                try:
                    successfully_sent_to = endpoint.__send(
                        packet.SerializeToString(),
                        [identity]
                    )
                except UnknownIdentity:
                    LOGGER.trace('Identity {} is unknown', identity)
                    continue

                if len(successfully_sent_to) == 0:
                    continue

                endpoint.__sender_window.send(packet_id)
                if not packet.acknowledgement_required:
                    endpoint.__sender_window.clear(packet_id)
                    endpoint.__execute_send_callback(
                        packet_id=packet_id,
                        success=True
                    )

                remote_peer.process_outbound_packet(packet)

                if len(remote_peer.send_queue) > 0:
                    remote_peer.send_queue.get_nowait()
                    remote_peer.send_queue.task_done()

    def __send_packet(
        self,
        base_packet: Packet,
        identity: str,
        callback: Optional[Callable[[], None]] = None
    ):
        self.__remote_peers[identity].send_queue.put((base_packet, callback))

    def __execute_send_callback(self, success, packet_id=None, callback=None):
        with self.__lock:
            if packet_id is not None:
                try:
                    callback = self.__send_callbacks[packet_id]
                except KeyError:
                    return

            try:
                callback(success)
            except Exception as exc:  # pylint: disable=broad-except
                LOGGER.exception(exc)

            self.__send_callbacks.pop(packet_id, None)

    @property
    def is_closed(self) -> bool:
        return (
            self.__model.is_halted_local(self.__current_state) and
            not self.__not_stale_remote_peers
        )

    def close(self, force=False) -> None:
        """Close the endpoint."""
        with self.__lock:
            if force:
                gevent.killall([
                    self.__pruner_greenlet,
                    self.__sender_greenlet,
                    self.__executor_greenlet,
                    self.__alive_checker_greenlet,
                    self.__hearbeater_greenlet
                ])
                self.__current_state = self.__model.LOCAL_END
                self.__remote_peers.clear()
            else:
                self.__event_queue.put((
                    1,
                    {Event.CLOSE},
                    self.EventArguments()
                ))
                while True:
                    if self.is_closed:
                        return
                    gevent.sleep(0.001)

    def send(
        self,
        message: Optional[Message] = None,
        identity: Optional[str] = None,
        is_close: bool = False,
        callback: Optional[Callable[[bool], None]] = None
    ):
        """Send a message and/or a close-request."""
        if (self.is_closed or
            self.__model.is_halted_local(self.__current_state)):
            raise EndpointIsClosed

        LOGGER.trace('Sending message...')
        events: Set[Event] = set()

        if message is not None:
            events.add(Event.OUTBOUND_PAYLOAD)
        if is_close:
            events.add(Event.OUTBOUND_CLOSE)

        if identity is None:
            events.add(Event.TO_ALL)
        else:
            events.add(Event.TO_ONE)

        is_new_peer = False
        if identity is not None and identity not in self.__remote_peers:
            events.add(Event.NEW_OUTBOUND_PEER)
            self.__create_remote_peer(identity=identity)
            is_new_peer = True

        args = self.EventArguments(
            outbound_message=message,
            to_identity=identity,
            send_callback=callback,
            new_peer=is_new_peer
        )

        LOGGER.trace(
            'Generated events while sending message: {}',
            ', '.join(sorted([e.name for e in events]))
        )
        LOGGER.trace(
            'Events arguments: {}',
            repr(args)
        )

        self.__event_queue.put((
            0,
            events,
            args
        ))

    def __create_remote_peer(self, identity, window_start=None):
        LOGGER.trace('Creating new peer: {}', identity)
        remote_peer = self.__remote_peers[identity] = RemotePeerState(
            identity=identity,
            model=self.__model,
            receiver_window_size=self.__receiver_window_size,
            receiver_window_start=window_start,
            acknowledgement_interval=(
                self.__acknowledgement_interval
            ),
            heartbeat_interval=self.__heartbeat_interval,
            alive_timeout=self.__alive_timeout,
            time=self.__time,
        )
        return remote_peer

    def __drop_remote_peer(self, identity):
        with self.__lock:
            remote_peer = self.__remote_peers.get(identity)
            if remote_peer is None:
                return

            for packet_id in remote_peer.unacknowledged_sent_packets:
                try:
                    self.__sender_window.clear(packet_id)
                except UnknownID:
                    pass
                finally:
                    self.__execute_send_callback(
                        packet_id=packet_id,
                        success=False
                    )
            del self.__remote_peers[identity]
            LOGGER.trace()

    def __process_inbound_payload(self, from_identity, inbound_packet):
        payload = self.__message_cls()

        try:
            payload.ParseFromString(inbound_packet.payload.value)
        except DecodeError:
            LOGGER.exception(
                'Received malformed payload. Terminating communication...',
                extra={'identity': from_identity}
            )
            self.__drop_remote_peer(from_identity)

        for callback in self.__receive_callbacks:
            # pylint: disable=broad-except
            try:
                callback(from_identity, payload)
            except Exception as exc:
                LOGGER.exception(exc)

    class EventArguments(NamedTuple):
        """Data associated with an events-set."""
        outbound_message: Optional[Message] = None
        inbound_packet: Optional[Packet] = None
        to_identity: Optional[str] = None
        from_identity: Optional[str] = None
        send_callback: Optional[Callable[[bool], None]] = None
        new_peer: bool = False

    def __execute_actions(
        self,
        actions: Set[Action],
        args: EventArguments,
        group: Set[str],
    ):
        # pylint: disable=no-member
        LOGGER.trace(
            'Executing actions: {}...',
            ', '.join(a.name for a in actions)
        )
        recipients = set()

        base_packet = self.__create_base_packet()

        if args.new_peer and args.to_identity is not None:
            base_packet.is_initial = True

        identity = None
        if args.to_identity is not None:
            identity = args.to_identity
        elif args.from_identity is not None:
            identity = args.from_identity

        if Action.REJECT in actions:
            if args.send_callback is not None:
                self.__execute_send_callback(
                    success=False,
                    callback=args.send_callback
                )
            if args.new_peer and identity is not None:
                self.__drop_remote_peer(identity)
            return
        else:
            if args.new_peer:
                state = self.__remote_peers.get(identity)
                if not state.is_accepted:
                    LOGGER.trace('Accepting new peer...')
                    state.accept()
        if Action.SEND_TO_ONE in actions:
            if args.to_identity is None:
                raise InvalidAction
            recipients.add(args.to_identity)
        if Action.SEND_TO_ALL in actions:
            recipients.update(set(group))
        if Action.SEND_TO_RANDOM in actions:
            recipients.add(rnd.choice(tuple(group)))
        if Action.SEND_REPLY in actions:
            if args.from_identity is None:
                raise InvalidAction
            recipients.add(args.from_identity)
        if Action.SEND_CLOSE in actions:
            base_packet.is_closing = True
        if Action.SEND_PAYLOAD in actions:
            if args.outbound_message is None:
                raise InvalidAction
            base_packet.payload.value = (
                args.outbound_message.SerializeToString()
            )
        if Action.SEND_ERROR is actions:
            base_packet.is_error = True
        if Action.REQUIRE_ACKNOWLEDGEMENT in actions:
            base_packet.acknowledgement_required = True

        if Action.PROCESS_INBOUND_PAYLOAD in actions:
            if (args.inbound_packet is None or
                not args.inbound_packet.HasField('payload') or
                args.from_identity is None):
                raise InvalidAction
            self.__process_inbound_payload(
                from_identity=args.from_identity,
                inbound_packet=args.inbound_packet,
            )
        LOGGER.trace('Base packet: {}', base_packet)
        for recipient in recipients:
            self.__send_packet(
                base_packet=base_packet,
                identity=recipient
            )

    @classmethod
    def __executor(
        cls,
        endpointref: weakref.ReferenceType,
    ):
        """Executed 'actions'.

        This method provides an interpreter for the actions
        outputted by the model.
        """
        endpoint: Optional[Endpoint] = None
        while True:
            del endpoint
            endpoint = endpointref()
            if endpoint is None:
                break
            if endpoint.is_closed:
                break
            gevent.sleep(0.001)

            try:
                _, events, args = endpoint.__event_queue.get_nowait()
            except gevent.queue.Empty:
                continue

            LOGGER.trace(
                'Processing events: {}...',
                ', '.join(e.name for e in events)
            )
            with endpoint.__lock:
                local_events = {e for e in events if e.is_local}

                next_state, actions = endpoint.__current_state, set()
                try:
                    next_state, actions = endpoint.__model.execute_local(
                        endpoint.__current_state,
                        local_events
                    )
                except UnrecognizedEventsSet:
                    pass
                except Halted:
                    continue
                LOGGER.trace(
                    'Old endpoint state: {}.',
                    endpoint.__current_state.name
                )
                endpoint.__current_state = next_state
                LOGGER.trace(
                    'New endpoint state: {}.',
                    endpoint.__current_state.name
                )
                endpoint.__execute_actions(
                    actions=actions,
                    args=args,
                    group=set(endpoint.__not_stale_remote_peers.keys())
                )
                remote_events = {e for e in events if e.is_remote}

                groups = collections.defaultdict(list)
                for identity, state in (
                    endpoint.__not_stale_remote_peers.items()
                ):
                    groups[state.current_state].append((
                        identity,
                        state
                    ))
                for current_state, group in groups.items():
                    next_state, actions = current_state, set()
                    try:
                        next_state, actions = endpoint.__model.execute_remote(
                            current_remote_state=current_state,
                            current_local_state=endpoint.__current_state,
                            events=remote_events
                        )
                    except UnrecognizedEventsSet:
                        pass
                    except Halted:
                        continue
                    for identity, state in group:
                        (endpoint
                            .__not_stale_remote_peers[identity]
                            .current_state) = next_state

                        if endpoint.__model.is_halted_remote(next_state):
                            endpoint.__event_queue.put((
                                1,
                                {Event.PEER_GONE},
                                cls.EventArguments()
                            ))
                    endpoint.__execute_actions(
                        actions=actions,
                        args=args,
                        group=list(zip(*group))[0]
                    )

    def on_receive(self, callback: Callable[[str, Message], None]):
        """Subscribe 'callback' to be called when a message is received."""
        if (self.is_closed or
            self.__model.is_halted_local(self.__current_state)):
            raise EndpointIsClosed

        self.__receive_callbacks.append(callback)

    def on_peer_lost(self, callback: Callable[[str], None]):
        """Subscribe 'callback' to be called when a remote peer is lost."""
        if (self.is_closed or
            self.__model.is_halted_local(self.__current_state)):
            raise EndpointIsClosed

        self.__peer_lost_callbacks.append(callback)

    def drop_peer(self, identity):
        """Drop peer immediately.

        If the peer is disconnected by some external reasons (transport
        connection is terminated) - this method is used to drop it.

        Normally this method should not be used by a user.
        """
        self.__drop_remote_peer(identity=identity)

    @property
    def remote_peers(self):
        """Active remote peers."""
        return [
            p for p in self.__not_closed_remote_peers.values()
            if p.is_accepted
        ]

    def consume_packet(self, from_identity: str, packet: Packet):
        """Process inbound packet.

        Normally this method should not be used by a user.
        """
        LOGGER.trace('Consuming packet...')
        if self.is_closed:
            raise EndpointIsClosed

        if (packet.service_id != self.__service_id or
            packet.method_id != self.__method_id):
            raise IncompatiblePacket

        if (self.__session_id is not None and
            not packet.HasField('session_id') and
            packet.session_id.value != self.__session_id):
            raise IncompatiblePacket

        if self.__session_id is None and packet.HasField('session_id'):
            raise IncompatiblePacket

        with self.__lock:
            is_new_peer = False
            state = self.__remote_peers.get(from_identity)
            if state is None:
                state = self.__create_remote_peer(
                    identity=from_identity,
                    window_start=packet.window_start
                )
                is_new_peer = True
            if state.is_stale:
                return
            accept = state.process_inbound_packet(packet=packet)
            if not accept:
                LOGGER.trace('Packet is not accepted - skipping.')
                return

            if packet.acknowledges:
                LOGGER.trace(
                    'Inbound packet acknowledges: {}',
                    ', '.join(map(str, packet.acknowledges))
                )
                for packet_id in packet.acknowledges:
                    try:
                        self.__sender_window.clear(packet_id=packet_id)
                        self.__execute_send_callback(
                            packet_id=packet_id,
                            success=True
                        )
                    except UnknownID:
                        continue

            # Do not generate events for heartbeats.
            if packet.is_heartbeat:
                LOGGER.trace(
                    'Skipping generating events for a heartbeat-packet...'
                )
                return
            # Do not generate event for the remote peers in "closed" state.
            if state.is_closed:
                return

            # Generate events.
            events = set()
            if packet.is_initial:
                events.add(Event.INBOUND_INITIAL)
            if packet.is_closing:
                events.add(Event.INBOUND_CLOSE)
            if packet.HasField('payload'):
                events.add(Event.INBOUND_PAYLOAD)
            if packet.acknowledgement_required:
                events.add(Event.REQUIRES_ACKNOWLEDGEMENT)
            if is_new_peer:
                events.add(Event.NEW_INBOUND_PEER)
            args = self.EventArguments(
                inbound_packet=packet,
                from_identity=from_identity,
                new_peer=is_new_peer
            )

            LOGGER.trace(
                'Generated events while consuming packet: {}',
                ', '.join(sorted([e.name for e in events]))
            )
            LOGGER.trace(
                'Events arguments: {}',
                repr(args)
            )

            self.__event_queue.put((
                0,
                events,
                args
            ))
